from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
from math import sin, cos, atan2, radians, sqrt, pi
import random
import time
import sys
player_arrows_fired = []
#surrender feature
surrender = False

# Global variables
GRID_LENGTH = 500
cam_angle_h = 45
cam_angle_v = 30
cam_dist = 4000
fovY = 60

# Game state variables
pause = False
show_trails = False
wireframe = False
enemies = []
projectiles = []
effects = []
wall_hp = {}
wall_max = {}
all_walls = []

# Player and game variables
player_coins = 0
castle_health = 100
max_castle_health = 200
player_arrows = 0
last_chest_time = 0
CHEST_COOLDOWN = 5
teleport_skip_clamp = False

# Camera variables
camera_radius = 8000
camera_height = 2500
camera_pos = [
    camera_radius * cos(radians(cam_angle_h)),
    camera_radius * sin(radians(cam_angle_h)),
    camera_height
]
fpp_mode = False
min_radius = 500
max_radius = 20000

# Lighting for enemies only
lightPos = [0.0, 0.0, 1000.0, 1.0]

# Enemy spawning
SPAWN_RADIUS = 6000.0
spawn_flags = {'barbarian': True, 'archer': True, 'giant': True, 'cannon': True}
spawn_timers = {'barbarian': 0.0, 'archer': 0.0, 'giant': 0.0, 'cannon': 0.0}

# Castle configurations
castle_configs = [
    {
        'position': [-800, -1600, 0],
        'size': 1600,
        'height': 800,
        'roof_z': 600,
        'tower_radius': 160,
        'floors': 7,
        'wall_thickness': 300,
        'wall_height': 600,
        'color_scheme': 'reddish',
        'chest': None
    },
    {
        'position': [900, 1000, 0],
        'size': 1600,
        'height': 1200,
        'roof_z': 800,
        'tower_radius': 180,
        'floors': 12,
        'wall_thickness': 400,
        'wall_height': 800,
        'color_scheme': 'reddish',
        'chest': {
            'position': [1200, 500, 0],
            'size': 100
        }
    },
    {
        'position': [-3300, 400, 0],
        'size': 2000,
        'height': 600,
        'roof_z': 450,
        'tower_radius': 120,
        'floors': 3,
        'wall_thickness': 300,
        'wall_height': 450,
        'color_scheme': 'reddish',
        'chest': None
    }
]

# Central rock tower position
central_rock_pos = [-1000, 1500, 0]
player_pos = [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]
player_speed = 50
player_angle = 0
player_turn_speed = 5

class PlayerArrow:
    def __init__(self, start_pos, target_pos, damage=50):
        self.start_pos = start_pos[:]
        self.target_pos = target_pos[:]
        self.current_pos = start_pos[:]
        self.t = 0.0
        self.speed = 1.5  # Slower speed for visibility
        self.damage = damage
        self.explosion_radius = 200.0
        self.life = 4.0  # Longer flight time
        self.active = True
        
        # Calculate better Bezier control points
        distance = sqrt((target_pos[0] - start_pos[0])**2 + (target_pos[1] - start_pos[1])**2)
        
        # Control point (arc peak)
        mid_x = (start_pos[0] + target_pos[0]) / 2
        mid_y = (start_pos[1] + target_pos[1]) / 2
        arc_height = 300 + distance * 0.4  # Higher arc for longer distances
        mid_z = max(start_pos[2], target_pos[2]) + arc_height
        
        # Bezier control points: start -> high arc -> target
        self.control_points = [
            start_pos[:],
            [mid_x, mid_y, mid_z],
            target_pos[:]
        ]

        
    def bezier_point(self, t, points):
        """Calculate point on quadratic Bezier curve"""
        if len(points) != 3:
            return points[0]
        
        # Quadratic Bezier formula: (1-t)²P₀ + 2(1-t)tP₁ + t²P₂
        t1 = 1 - t
        t_squared = t * t
        t1_squared = t1 * t1
        
        return [
            t1_squared * points[0][0] + 2 * t1 * t * points[1][0] + t_squared * points[2][0],
            t1_squared * points[0][1] + 2 * t1 * t * points[1][1] + t_squared * points[2][1],
            t1_squared * points[0][2] + 2 * t1 * t * points[1][2] + t_squared * points[2][2]
        ]

    
    def update(self, dt):
        if not self.active:
            return
            
        self.life -= dt
        self.t += self.speed * dt
        
        if self.t >= 1.0 or self.life <= 0:
            # Arrow reached target or timed out
            self.explode()
            self.active = False
        else:
            # Update position along Bezier curve
            self.current_pos = self.bezier_point(self.t, self.control_points)
    
    def explode(self):
        """Create explosion effect and damage enemies in radius"""
        explosion_pos = self.current_pos[:]
        
        # Create explosion particle effect
        effects.append(ParticleBurst(explosion_pos, size=80, count=60))
        
        # Damage all enemies within explosion radius
        enemies_hit = 0
        for enemy in enemies[:]:  # Create copy to safely modify during iteration
            dx = enemy.pos[0] - explosion_pos[0]
            dy = enemy.pos[1] - explosion_pos[1]
            dz = enemy.pos[2] - explosion_pos[2]
            distance = sqrt(dx*dx + dy*dy + dz*dz)
            
            if distance <= self.explosion_radius:
                # Calculate damage falloff (more damage at center)
                damage_multiplier = max(0.3, 1.0 - (distance / self.explosion_radius))
                actual_damage = int(self.damage * damage_multiplier)
                
                enemy.hp -= actual_damage
                enemies_hit += 1
                
                # Create hit effect on enemy
                effects.append(ParticleBurst([enemy.pos[0], enemy.pos[1], enemy.pos[2] + 50], size=30, count=20))
        
        print(f"Arrow exploded! Hit {enemies_hit} enemies")
    
    def draw(self):
        if not self.active:
            return
        
        
        
        # Draw the full bezier curve trajectory as a line
        draw_bezier_curve_line(self.control_points, segments=50)
        
        # Draw current arrow position
        glPushMatrix()
        glTranslatef(self.current_pos[0], self.current_pos[1], self.current_pos[2])
        
        # Bright yellow arrow marker
        glColor3f(1.0, 1.0, 0.0)
        glPointSize(15.0)
        glBegin(GL_POINTS)
        glVertex3f(0, 0, 0)
        glEnd()
        
        # Arrow cross shape
        glColor3f(0.0, 1.0, 0.0)  # Green cross
        glLineWidth(5.0)
        glBegin(GL_LINES)
        glVertex3f(-15, 0, 0)
        glVertex3f(15, 0, 0)
        glVertex3f(0, -15, 0)
        glVertex3f(0, 15, 0)
        glVertex3f(0, 0, -15)
        glVertex3f(0, 0, 15)
        glEnd()
        
        glPopMatrix()
        

        
def bezier_point_static(t, points):
    """Static version of bezier calculation for drawing curve"""
    if len(points) != 3:
        return points[0]
    
    t1 = 1 - t
    t_squared = t * t
    t1_squared = t1 * t1
    
    return [
        t1_squared * points[0][0] + 2 * t1 * t * points[1][0] + t_squared * points[2][0],
        t1_squared * points[0][1] + 2 * t1 * t * points[1][1] + t_squared * points[2][1],
        t1_squared * points[0][2] + 2 * t1 * t * points[1][2] + t_squared * points[2][2]
    ]




def draw_bezier_curve_line(control_points, segments=50):
        """Draw a line showing the bezier curve trajectory"""
        
        glColor3f(1.0, 0.0, 0.0)  # Red line for visibility
        glLineWidth(3.0)
        
        glBegin(GL_LINE_STRIP)
        for i in range(segments + 1):
            t = i / segments
            point = bezier_point_static(t, control_points)
            glVertex3f(point[0], point[1], point[2])
        glEnd()
        
        




def draw_light_bow():
    """Draws a light bow using the same positioning as test cube"""
    global player_pos, player_angle
    
    glPushMatrix()
    
    # Get player position and angle
    px, py, pz = player_pos
    
    # Use EXACT same positioning as test cube
    glTranslatef(px, py, pz + 80)  # Move to player position + height offset
    glRotatef(player_angle, 0, 0, 1)  # Rotate with player
    glTranslatef(0, 60, 0)  # Position in front of player (same as test cube)
    
    # Additional bow-specific positioning (fine-tuning)
    glTranslatef(15, -30, -10)  # Your original bow offset
    glRotatef(-15, 1, 0, 0)     # Downward tilt
    glScalef(0.8, 0.8, 0.8)     # Scale down
    glRotatef(0, 0, 90, 1) 
    glRotatef(90, 90, 0, 1) 
    glRotatef(180, 00, 0, 1) 
    # Bow curve using connected line segments
    glColor3f(0.8, 0.5, 0.2)  # Wood brown color
    glLineWidth(4.0)
    glBegin(GL_LINE_STRIP)
    for i in range(-30, 31, 2):
        angle = i * 3  # degrees
        rad = radians(angle)
        x = 0
        y = i * 4  # vertical spacing
        z = 20 * sin(rad)  # curve depth
        glVertex3f(x, y, z)
    glEnd()
    
    # Bow string
    glColor3f(0.9, 0.9, 0.8)
    glLineWidth(4.0)
    glBegin(GL_LINES)
    glVertex3f(0, -120, 20 * sin(radians(-90)))
    glVertex3f(0, 120, 20 * sin(radians(90)))
    glEnd()

    if player_arrows > 0:
        glPushMatrix()
        glRotatef(70, 45, 0, 1) 
        glTranslatef(-15, -30, 0)
        # Arrow shaft
        
        glColor3f(0.6, 0.4, 0.2)
        glLineWidth(5.0)
        glBegin(GL_LINES)
        glVertex3f(0, 0, 15)
        glVertex3f(0, -80, 15)
        glEnd()
        
        # Arrow fletching (feathers)
        glColor3f(0.8, 0.8, 0.9)
        glPointSize(3.0)
        glBegin(GL_POINTS)
        for offset in [-2, 0, 2]:
            glVertex3f(offset, 10, 15)
            glVertex3f(offset, 15, 15)
        glEnd()
        
        # Arrow tip
        glColor3f(0.7, 0.7, 0.7)
        glLineWidth(5.0)
        glBegin(GL_TRIANGLES)
        glVertex3f(0, -80, 15)
        glVertex3f(-2, -75, 15)
        glVertex3f(2, -75, 15)
        glEnd()
        glPopMatrix()
    glPopMatrix()

    
    
    
    
def shoot_arrow():
    """Shoot an arrow if player has arrows available"""
    global player_arrows, player_arrows_fired
    
    if player_arrows <= 0:
        print("No arrows left!")
        return
    
    # Calculate shooting position (from bow)
    px, py, pz = player_pos
    shoot_pos = [px, py, pz + 80]
    
    # Calculate target position (far in front of player)
    rad = radians(player_angle + 90)
    target_distance = 2000  # How far the arrow will travel
    target_pos = [
        px + cos(rad) * target_distance,
        py + sin(rad) * target_distance,
        pz - 100  # Slight downward trajectory
    ]
    
    # Create and fire arrow
    arrow = PlayerArrow(shoot_pos, target_pos, damage=60)
    player_arrows_fired.append(arrow)
    player_arrows -= 1
    
    print(f"Arrow fired! Arrows remaining: {player_arrows}")


# 
# Wall collision detection
class Wall:
    def __init__(self, x1, y1, x2, y2, thickness, height, owner):
        self.minx = min(x1, x2) - thickness / 2
        self.maxx = max(x1, x2) + thickness / 2
        self.miny = min(y1, y2) - thickness / 2
        self.maxy = max(y1, y2) + thickness / 2
        self.height = height
        self.owner = owner
        self.center = [(self.minx + self.maxx) / 2, (self.miny + self.maxy) / 2, height / 2]

    def intersects(self, pos):
        return self.minx < pos[0] < self.maxx and self.miny < pos[1] < self.maxy

# Utility functions
def get_color_scheme(scheme_name, base_color):
    if scheme_name == 'reddish':
        return [min(1.0, base_color[0] * 1.2), base_color[1] * 0.8, base_color[2] * 0.8]
    else:
        return base_color

def vec_to(a, b):
    return [b[0]-a[0], b[1]-a[1], b[2]-a[2]]

def norm(v):
    return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])

def check_collision(pos1, pos2, radius):
    dx = pos1[0] - pos2[0]
    dy = pos1[1] - pos2[1]
    dz = pos1[2] - pos2[2]
    return sqrt(dx*dx + dy*dy + dz*dz) < radius

def rand_spawn_pos():
    a = random.uniform(0, 2*pi)
    return [cos(a)*SPAWN_RADIUS, sin(a)*SPAWN_RADIUS, 0.0]

def get_camera_eye():
    th = radians(cam_angle_h)
    ph = radians(cam_angle_v)
    cx = cos(th)*cos(ph)*cam_dist
    cy = sin(th)*cos(ph)*cam_dist
    cz = sin(ph)*cam_dist
    target = [castle_configs[0]['position'][0], castle_configs[0]['position'][1], castle_configs[0]['wall_height']]
    return [cx+target[0], cy+target[1], cz+target[2]]

# Drawing functions with manual shading (from paste.txt)
def draw_cube_manual_shading(x, y, z, dx, dy, dz, base_color):
    """Draw cube with manual face shading"""
    glPushMatrix()
    glTranslatef(x, y, z)
    
    # Face colors with different brightness
    top_color = [min(1.0, c * 1.3) for c in base_color]
    front_color = base_color
    side_color = [c * 0.7 for c in base_color]
    back_color = [c * 0.5 for c in base_color]
    
    glBegin(GL_QUADS)
    # Top face (brightest)
    glColor3f(top_color[0], top_color[1], top_color[2])
    glVertex3f(-dx/2, dy/2, -dz/2)
    glVertex3f(-dx/2, dy/2, dz/2)
    glVertex3f(dx/2, dy/2, dz/2)
    glVertex3f(dx/2, dy/2, -dz/2)
    
    # Front face
    glColor3f(front_color[0], front_color[1], front_color[2])
    glVertex3f(-dx/2, -dy/2, dz/2)
    glVertex3f(dx/2, -dy/2, dz/2)
    glVertex3f(dx/2, dy/2, dz/2)
    glVertex3f(-dx/2, dy/2, dz/2)
    
    # Right face
    glColor3f(side_color[0], side_color[1], side_color[2])
    glVertex3f(dx/2, -dy/2, -dz/2)
    glVertex3f(dx/2, dy/2, -dz/2)
    glVertex3f(dx/2, dy/2, dz/2)
    glVertex3f(dx/2, -dy/2, dz/2)
    
    # Left face
    glColor3f(side_color[0], side_color[1], side_color[2])
    glVertex3f(-dx/2, -dy/2, -dz/2)
    glVertex3f(-dx/2, -dy/2, dz/2)
    glVertex3f(-dx/2, dy/2, dz/2)
    glVertex3f(-dx/2, dy/2, -dz/2)
    
    # Back face
    glColor3f(back_color[0], back_color[1], back_color[2])
    glVertex3f(-dx/2, -dy/2, -dz/2)
    glVertex3f(-dx/2, dy/2, -dz/2)
    glVertex3f(dx/2, dy/2, -dz/2)
    glVertex3f(dx/2, -dy/2, -dz/2)
    
    # Bottom face
    glColor3f(side_color[0], side_color[1], side_color[2])
    glVertex3f(-dx/2, -dy/2, -dz/2)
    glVertex3f(dx/2, -dy/2, -dz/2)
    glVertex3f(dx/2, -dy/2, dz/2)
    glVertex3f(-dx/2, -dy/2, dz/2)
    glEnd()
    
    glPopMatrix()

# Enemy lighting functions (only for enemies)
def set_material(color, emission=(0.0, 0.0, 0.0)):
    glMaterialfv(GL_FRONT, GL_DIFFUSE, color + (1.0,))
    glMaterialfv(GL_FRONT, GL_SPECULAR, (0.5, 0.5, 0.5, 1.0))
    glMaterialfv(GL_FRONT, GL_EMISSION, emission + (1.0,))
    glMaterialfv(GL_FRONT, GL_SHININESS, 50.0)

def draw_sphere(radius):
    quad = gluNewQuadric()
    gluSphere(quad, radius, 16, 16)

def draw_cylinder(radius, height):
    quad = gluNewQuadric()
    gluCylinder(quad, radius, radius, height, 16, 16)

def draw_human(x, y, z, scale=80):
    quad = gluNewQuadric()
    glPushMatrix()
    
    glTranslatef(x, y, z)
    glRotatef(player_angle, 0, 0, 1)
    glScalef(scale/100, scale/100, scale/100)
    
    # Torso (blue shirt)
    draw_cube_manual_shading(0, 0, 120, 80, 40, 150, [0.2, 0.4, 1.0])
    
    # Head (skin color)
    glPushMatrix()
    glTranslatef(0, 0, 250)
    glColor3f(1.0, 0.8, 0.6)
    gluSphere(quad, 50, 16, 16)
    glPopMatrix()
    
    # Arms (skin color) - pointing forward
    arm_radius = 15
    arm_length = 100
    glColor3f(1.0, 0.8, 0.6)
    
    # Right arm
    glPushMatrix()
    glTranslatef(60, 0, 180)
    glRotatef(-90, 1, 0, 0)
    gluCylinder(quad, arm_radius, arm_radius, arm_length, 8, 8)
    glPopMatrix()
    
    # Left arm
    glPushMatrix()
    glTranslatef(-60, 0, 180)
    glRotatef(-90, 1, 0, 0)
    gluCylinder(quad, arm_radius, arm_radius, arm_length, 8, 8)
    glPopMatrix()
    
    # Legs (skin color)
    leg_radius = 20
    leg_length = 120
    glColor3f(1.0, 0.8, 0.6)
    
    # Right leg
    glPushMatrix()
    glTranslatef(25, 0, 0)
    gluCylinder(quad, leg_radius, leg_radius, leg_length, 8, 8)
    glPopMatrix()
    
    # Left leg
    glPushMatrix()
    glTranslatef(-25, 0, 0)
    gluCylinder(quad, leg_radius, leg_radius, leg_length, 8, 8)
    glPopMatrix()
    
    glPopMatrix()

# Particle system
class ParticleBurst:
    def __init__(self, pos, size=40, count=28):
        self.pos = pos[:]
        self.size = size
        self.count = count
        self.life = 1.0
        self.particles = []
        for _ in range(count):
            angle = random.uniform(0, 2*pi)
            speed = random.uniform(50, 150)
            vx = cos(angle) * speed
            vy = sin(angle) * speed
            vz = random.uniform(50, 200)
            self.particles.append({
                'pos': pos[:],
                'vel': [vx, vy, vz],
                'life': random.uniform(0.5, 1.5)
            })

    def update(self, dt):
        self.life -= dt
        for p in self.particles:
            p['pos'][0] += p['vel'][0] * dt
            p['pos'][1] += p['vel'][1] * dt
            p['pos'][2] += p['vel'][2] * dt - 500 * dt * dt
            p['life'] -= dt

    def draw(self):
        
        glPointSize(5.0)
        glBegin(GL_POINTS)
        for p in self.particles:
            if p['life'] > 0:
                glColor3f(0.8, 0.8, 0.8)
                glVertex3f(p['pos'][0], p['pos'][1], p['pos'][2])
        glEnd()
        glPointSize(1.0)
        

# Projectile system
class Projectile:
    def __init__(self, pos, vel, radius=6.0, kind='arrow', damage=6):
        self.pos = pos[:]
        self.vel = vel[:]
        self.radius = radius
        self.kind = kind
        self.life = 5.0
        self.trail = []
        self.damage = damage

    def update(self, dt):
        self.life -= dt
        self.pos[0] += self.vel[0] * dt
        self.pos[1] += self.vel[1] * dt
        self.pos[2] += self.vel[2] * dt - 500 * dt * dt
        if show_trails:
            self.trail.append(self.pos[:])
            if len(self.trail) > 20:
                self.trail.pop(0)

    def draw(self):
        
        set_material((0.2, 0.2, 0.2) if self.kind == 'arrow' else (0.3, 0.3, 0.3))
        glPushMatrix()
        glTranslatef(self.pos[0], self.pos[1], self.pos[2])
        draw_sphere(self.radius)
        glPopMatrix()
        if show_trails and self.trail:
            
            glLineWidth(2.0)
            glBegin(GL_LINE_STRIP)
            glColor3f(0.5, 0.5, 0.5)
            for p in self.trail:
                glVertex3f(p[0], p[1], p[2])
            glEnd()
            glLineWidth(1.0)
            

# Enemy system
class Enemy:
    def __init__(self, pos, speed=200.0, attack_range=140, attack_rate=1.4, damage=8):
        self.pos = [float(pos[0]), float(pos[1]), float(pos[2])]
        self.speed = speed
        self.state = 'advance'
        self.attack_cool = 0.0
        self.hp = 100
        self.max_hp = 100
        self.attacking = False
        self.target_wall = None
        self.attack_range = attack_range
        self.attack_rate = attack_rate
        self.damage = damage

    def target_point(self):
        if self.target_wall:
            return self.target_wall.center
        cfg = castle_configs[0]  # Target first castle
        x, y = cfg['position'][0], cfg['position'][1]
        size = cfg['size']
        wall_t = cfg['wall_thickness']
        half = size/2.0 + wall_t/2.0 + 100.0
        return [x, y-half, cfg['wall_height']*0.5]

    def update(self, dt):
        tp = self.target_point()
        delta = vec_to(self.pos, tp)
        d = norm(delta)
        if not self.attacking:
            if d > self.attack_range:
                dirx = delta[0] / d
                diry = delta[1] / d
                step = self.speed * dt
                new_x = self.pos[0] + dirx * step
                new_y = self.pos[1] + diry * step
                intersect_wall = None
                for wall in all_walls:
                    if wall.intersects([new_x, new_y, 0]):
                        intersect_wall = wall
                        break
                if intersect_wall:
                    self.attacking = True
                    self.target_wall = intersect_wall
                    self.attack_cool = 0.0
                else:
                    self.pos[0] = new_x
                    self.pos[1] = new_y
            else:
                self.attacking = True
                self.attack_cool = 0.0
        else:
            self.attack_cool -= dt
            if self.attack_cool <= 0:
                self.attack_cool = self.attack_rate
                owner = self.target_wall.owner if self.target_wall else 0
                if owner in wall_hp:
                    wall_hp[owner] = max(0, wall_hp[owner] - self.damage)
                hit_pos = tp
                effects.append(ParticleBurst(hit_pos, size=40, count=28))

    def draw_hp_bar(self):
        if self.hp <= 0:
            return
        size = 60.0
        pct = max(0.0, self.hp/self.max_hp)
        eye = get_camera_eye()
        dir_cam = [eye[0]-self.pos[0], eye[1]-self.pos[1], eye[2]-(self.pos[2]+220)]
        rx = -dir_cam[1]
        ry = dir_cam[0]
        rz = 0.0
        rlen = sqrt(max(1e-6, rx*rx+ry*ry))
        rx /= rlen
        ry /= rlen
        ux = 0
        uy = 0
        uz = 1.0
        cx = self.pos[0]
        cy = self.pos[1]
        cz = self.pos[2] + 330.0
        
        glColor3f(0.15, 0.15, 0.15)
        glBegin(GL_QUADS)
        glVertex3f(cx - rx*size - ux*6, cy - ry*size - uy*6, cz - uz*6)
        glVertex3f(cx + rx*size - ux*6, cy + ry*size - uy*6, cz - uz*6)
        glVertex3f(cx + rx*size + ux*6, cy + ry*size + uy*6, cz + uz*6)
        glVertex3f(cx - rx*size + ux*6, cy - ry*size + uy*6, cz + uz*6)
        glEnd()
        glColor3f(1.0-pct, pct, 0.1)
        glBegin(GL_QUADS)
        hw = size*0.98*pct
        glVertex3f(cx - rx*size, cy - ry*size, cz)
        glVertex3f(cx - rx*size + rx*hw, cy - ry*size + ry*hw, cz)
        glVertex3f(cx - rx*size + rx*hw + ux*6, cy - ry*size + ry*hw + uy*6, cz + uz*6)
        glVertex3f(cx - rx*size + ux*6, cy - ry*size + uy*6, cz + uz*6)
        glEnd()
        

class Barbarian(Enemy):
    def __init__(self, pos):
        super().__init__(pos, speed=260.0, attack_range=140, attack_rate=1.4, damage=8)
        self.swing_phase = 0.0
        self.hp = 90
        self.max_hp = 90

    def update(self, dt):
        super().update(dt)
        if self.attacking:
            self.swing_phase += dt*6.0

    def draw(self):
        
        glPushMatrix()
        glTranslatef(self.pos[0], self.pos[1], 0)
        set_material((0.8, 0.6, 0.5))
        glPushMatrix()
        glTranslatef(-18, 0, 70)
        glScalef(20, 20, 140)
        draw_sphere(0.5)
        glPopMatrix()
        glPushMatrix()
        glTranslatef(18, 0, 70)
        glScalef(20, 20, 140)
        draw_sphere(0.5)
        glPopMatrix()
        set_material((0.4, 0.3, 0.2))
        glPushMatrix()
        glTranslatef(0, 0, 170)
        glScalef(80, 40, 140)
        draw_sphere(0.5)
        glPopMatrix()
        set_material((0.8, 0.6, 0.5))
        glPushMatrix()
        glTranslatef(0, 0, 260)
        draw_sphere(28)
        glPopMatrix()
        glPopMatrix()
        self.draw_hp_bar()

class Giant(Enemy):
    def __init__(self, pos):
        super().__init__(pos, speed=150.0, attack_range=300, attack_rate=2.0, damage=22)
        self.swing = 0.0
        self.hp = 260
        self.max_hp = 260

    def update(self, dt):
        super().update(dt)
        if self.attacking:
            self.swing += dt*2.0

    def draw(self):
        
        scale = 2.0
        glPushMatrix()
        glTranslatef(self.pos[0], self.pos[1], 0)
        glScalef(scale, scale, scale)
        set_material((0.6, 0.5, 0.4))
        glPushMatrix()
        glTranslatef(0, 0, 200)
        glScalef(110, 50, 180)
        draw_sphere(0.5)
        glPopMatrix()
        glPushMatrix()
        glTranslatef(0, 0, 300)
        draw_sphere(36)
        glPopMatrix()
        glPopMatrix()
        self.draw_hp_bar()

class Archer(Enemy):
    def __init__(self, pos):
        super().__init__(pos, speed=240.0, attack_range=1200, attack_rate=random.uniform(1.0, 1.8), damage=6)
        self.reload = random.uniform(1.2, 2.0)
        self.hp = 70
        self.max_hp = 70

    def update(self, dt):
        super().update(dt)
        if self.attacking:
            self.reload -= dt
            if self.reload <= 0:
                self.reload = self.attack_rate
                tp = self.target_point()
                delta = vec_to(self.pos, tp)
                d = norm(delta)
                dirx, diry, dirz = delta[0]/d, delta[1]/d, delta[2]/d
                speed = 900.0
                proj_vel = [dirx*speed, diry*speed, dirz*speed + 180.0]
                projectiles.append(Projectile([self.pos[0], self.pos[1], 160.0], proj_vel, radius=6.0, kind='arrow', damage=self.damage))

    def draw(self):
        
        glPushMatrix()
        glTranslatef(self.pos[0], self.pos[1], 0)
        set_material((0.3, 0.4, 0.2))
        glPushMatrix()
        glTranslatef(0, 0, 150)
        glScalef(60, 30, 120)
        draw_sphere(0.5)
        glPopMatrix()
        glPushMatrix()
        glTranslatef(0, 0, 220)
        draw_sphere(22)
        glPopMatrix()
        glPopMatrix()
        self.draw_hp_bar()

class Cannon(Enemy):
    def __init__(self, pos):
        super().__init__(pos, speed=160.0, attack_range=2200, attack_rate=random.uniform(2.0, 3.0), damage=30)
        self.reload = random.uniform(2.2, 3.4)
        self.hp = 120
        self.max_hp = 120

    def update(self, dt):
        super().update(dt)
        if self.attacking:
            self.reload -= dt
            if self.reload <= 0:
                self.reload = self.attack_rate
                tp = self.target_point()
                delta = vec_to(self.pos, tp)
                d = norm(delta)
                dirx, diry, dirz = delta[0]/d, delta[1]/d, delta[2]/d
                v0 = 1100.0
                projectiles.append(Projectile([self.pos[0], self.pos[1], 120.0], [dirx*v0, diry*v0, dirz*v0 + 200.0], radius=30.0, kind='ball', damage=self.damage))

    def draw(self):
        
        glPushMatrix()
        glTranslatef(self.pos[0], self.pos[1], 0)
        set_material((0.2, 0.2, 0.2))
        for sx in (-40, 40):
            glPushMatrix()
            glTranslatef(sx, -24, 36)
            glRotatef(90, 0, 1, 0)
            draw_cylinder(22, 12)
            glPopMatrix()
        set_material((0.4, 0.25, 0.1))
        glPushMatrix()
        glTranslatef(0, 0, 40)
        glScalef(160, 80, 40)
        draw_sphere(0.5)
        glPopMatrix()
        set_material((0.2, 0.2, 0.2))
        glPushMatrix()
        glTranslatef(0, 0, 90)
        glRotatef(10, 1, 0, 0)
        draw_cylinder(20, 140)
        glPopMatrix()
        glPopMatrix()
        self.draw_hp_bar()

# Spawning system
def spawn_enemy(kind):
    pos = rand_spawn_pos()
    if kind == 'barbarian':
        enemies.append(Barbarian(pos))
    elif kind == 'archer':
        enemies.append(Archer(pos))
    elif kind == 'giant':
        enemies.append(Giant(pos))
    elif kind == 'cannon':
        enemies.append(Cannon(pos))

def update_spawning(dt):
    spawn_timers['barbarian'] -= dt
    if spawn_flags['barbarian'] and spawn_timers['barbarian'] <= 0:
        spawn_timers['barbarian'] = random.uniform(3.0, 5.5)
        enemies.append(Barbarian(rand_spawn_pos()))
    spawn_timers['archer'] -= dt
    if spawn_flags['archer'] and spawn_timers['archer'] <= 0:
        spawn_timers['archer'] = random.uniform(4.2, 5.5)
        enemies.append(Archer(rand_spawn_pos()))
    spawn_timers['giant'] -= dt
    if spawn_flags['giant'] and spawn_timers['giant'] <= 0:
        spawn_timers['giant'] = random.uniform(5.0, 8.0)
        enemies.append(Giant(rand_spawn_pos()))
    spawn_timers['cannon'] -= dt
    if spawn_flags['cannon'] and spawn_timers['cannon'] <= 0:
        spawn_timers['cannon'] = random.uniform(6.0, 9.0)
        enemies.append(Cannon(rand_spawn_pos()))

# Wall system initialization
def init_walls():
    global all_walls
    all_walls = []
    # Perimeter walls
    wall_thickness = 200
    wall_height = 400
    buildings_to_encapsulate = [
        castle_configs[0],
        castle_configs[2],
        {'position': central_rock_pos, 'size': 800}
    ]
    min_x = min([pos['position'][0] - pos['size']/2 for pos in buildings_to_encapsulate]) - 500
    max_x = max([pos['position'][0] + pos['size']/2 for pos in buildings_to_encapsulate]) + 500
    min_y = min([pos['position'][1] - pos['size']/2 for pos in buildings_to_encapsulate]) - 500
    max_y = max([pos['position'][1] + pos['size']/2 for pos in buildings_to_encapsulate]) + 500
    wall_segments = [
        (min_x, max_y, max_x, max_y),
        (max_x, max_y, max_x, min_y),
        (max_x, min_y, min_x, min_y),
        (min_x, min_y, min_x, max_y)
    ]
    for x1, y1, x2, y2 in wall_segments:
        all_walls.append(Wall(x1, y1, x2, y2, wall_thickness, wall_height, 'perimeter'))
    # Castle walls
    for i, config in enumerate(castle_configs):
        pos = config['position']
        size = config['size']
        wall_thickness = config['wall_thickness']
        wall_height = config['wall_height']
        half_size = size / 2
        corners = [
            (pos[0] + half_size, pos[1] + half_size),
            (pos[0] - half_size, pos[1] + half_size),
            (pos[0] - half_size, pos[1] - half_size),
            (pos[0] + half_size, pos[1] - half_size)
        ]
        wall_inset = 50
        for j in range(len(corners)):
            x1, y1 = corners[j]
            x2, y2 = corners[(j + 1) % len(corners)]
            dx, dy = x2 - x1, y2 - y1
            length = (dx**2 + dy**2)**0.5
            if length > 0:
                dx_norm, dy_norm = dx / length * wall_inset, dy / length * wall_inset
            else:
                dx_norm, dy_norm = 0, 0
            wall_x1, wall_y1 = x1 + dx_norm, y1 + dy_norm
            wall_x2, wall_y2 = x2 - dx_norm, y2 - dy_norm
            all_walls.append(Wall(wall_x1, wall_y1, wall_x2, wall_y2, wall_thickness, wall_height, i))

# Structure drawing functions (with manual shading from paste.txt)
def draw_perimeter_wall():
    wall_thickness = 200
    wall_height = 400
    wall_color = [0.7, 0.7, 0.6]
    buildings_to_encapsulate = [
        castle_configs[0],
        castle_configs[2],
        {'position': central_rock_pos, 'size': 800}
    ]
    min_x = min([pos['position'][0] - pos['size']/2 for pos in buildings_to_encapsulate]) - 500
    max_x = max([pos['position'][0] + pos['size']/2 for pos in buildings_to_encapsulate]) + 500
    min_y = min([pos['position'][1] - pos['size']/2 for pos in buildings_to_encapsulate]) - 500
    max_y = max([pos['position'][1] + pos['size']/2 for pos in buildings_to_encapsulate]) + 500
    wall_segments = [
        (min_x, max_y, max_x, max_y),
        (max_x, max_y, max_x, min_y),
        (max_x, min_y, min_x, min_y),
        (min_x, min_y, min_x, max_y)
    ]
    for x1, y1, x2, y2 in wall_segments:
        draw_wall_segment(x1, y1, x2, y2, 0, wall_thickness, wall_height, wall_color)
        draw_perimeter_stone_blocks(x1, y1, x2, y2, 0, wall_thickness, wall_height)
    corners = set()
    for x1, y1, x2, y2 in wall_segments:
        corners.add((x1, y1))
        corners.add((x2, y2))
    for corner_x, corner_y in corners:
        draw_guard_tower(corner_x, corner_y, wall_height)

def draw_wall_segment(x1, y1, x2, y2, offset_z, thickness, height, color):
    midx = (x1 + x2) / 2
    midy = (y1 + y2) / 2
    length = ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    glPushMatrix()
    glTranslatef(midx, midy, offset_z + height/2)
    angle = atan2(y2 - y1, x2 - x1) * 180 / 3.14159
    glRotatef(angle, 0, 0, 1)
    draw_cube_manual_shading(0, 0, 0, length, thickness, height, color)
    glPopMatrix()

def draw_perimeter_stone_blocks(x1, y1, x2, y2, offset_z, thickness, height):
    length = ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    angle = atan2(y2 - y1, x2 - x1) * 180 / 3.14159
    block_width, block_height, gap = 150, 80, 15
    blocks_x = int(length / (block_width + gap))
    blocks_z = int(height / (block_height + gap))
    midx, midy = (x1 + x2) / 2, (y1 + y2) / 2
    for row in range(blocks_z):
        for col in range(blocks_x):
            offset = (block_width + gap) / 2 if (row % 2 == 1) else 0
            block_x_local = -length/2 + col * (block_width + gap) + block_width/2 + offset
            block_z_local = row * (block_height + gap) + block_height/2
            if abs(block_x_local) > length/2 - block_width/2:
                continue
            cos_a, sin_a = cos(radians(angle)), sin(radians(angle))
            world_x = midx + block_x_local * cos_a
            world_y = midy + block_x_local * sin_a
            world_z = offset_z + block_z_local + 15
            base_r, base_g, base_b = 0.75, 0.75, 0.65
            variation = 0.1 * ((row + col) % 4 - 2) / 2
            block_color = [
                min(max(base_r + variation, 0.0), 1.0),
                min(max(base_g + variation, 0.0), 1.0),
                min(max(base_b + variation, 0.0), 1.0)
            ]
            glPushMatrix()
            glTranslatef(world_x, world_y, world_z)
            glRotatef(angle, 0, 0, 1)
            draw_cube_manual_shading(0, 0, 0, block_width, thickness + 5, block_height, block_color)
            glPopMatrix()

def draw_guard_tower(x, y, wall_height):
    tower_radius = 60
    tower_height = wall_height + 200
    tower_color = [0.6, 0.6, 0.55]
    quad = gluNewQuadric()
    glPushMatrix()
    glTranslatef(x, y, 0)
    glColor3f(tower_color[0], tower_color[1], tower_color[2])
    gluCylinder(quad, tower_radius, tower_radius, tower_height, 16, 16)
    glTranslatef(0, 0, tower_height)
    roof_color = [0.8, 0.3, 0.2]
    glColor3f(roof_color[0], roof_color[1], roof_color[2])
    gluCylinder(quad, tower_radius + 10, 5, tower_radius, 12, 12)
    glPopMatrix()
    battlement_color = [0.5, 0.5, 0.45]
    for angle in range(0, 360, 30):
        rad = radians(angle)
        bx = x + (tower_radius + 15) * cos(rad)
        by = y + (tower_radius + 15) * sin(rad)
        draw_cube_manual_shading(bx, by, wall_height + 150, 20, 20, 50, battlement_color)

def draw_rope(start_pos, end_pos, segments=20):
    x1, y1, z1 = start_pos
    x2, y2, z2 = end_pos
    glColor3f(0.4, 0.3, 0.2)
    glLineWidth(3.0)
    distance = sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)
    sag_factor = min(100, distance * 0.1)
    glBegin(GL_LINE_STRIP)
    for i in range(segments + 1):
        t = i / segments
        x = x1 + t * (x2 - x1)
        y = y1 + t * (y2 - y1)
        z = z1 + t * (z2 - z1)
        sag = sag_factor * (4 * t * (1 - t))
        z -= sag
        glVertex3f(x, y, z)
    glEnd()
    glLineWidth(1.0)

def draw_rope_support_bar(x, y, z, height=200):
    glColor3f(0.3, 0.3, 0.3)
    bar_radius = 8
    quad = gluNewQuadric()
    glPushMatrix()
    glTranslatef(x, y, z)
    gluCylinder(quad, bar_radius, bar_radius, height, 16, 16)
    glTranslatef(0, 0, height)
    gluDisk(quad, 0, bar_radius, 16, 1)
    glTranslatef(0, 0, 5)
    glRotatef(90, 0, 1, 0)
    gluCylinder(quad, 5, 5, 30, 8, 8)
    glPopMatrix()

def draw_platform_with_gap(x, y, z, radius, gap_angle_start=0, gap_angle_end=45, color_scheme='normal'):
    platform_thickness = 20
    base_color = [0.7, 0.7, 0.65]
    platform_color = get_color_scheme(color_scheme, base_color)
    glPushMatrix()
    glTranslatef(x, y, z + platform_thickness/2)
    glColor3f(platform_color[0], platform_color[1], platform_color[2])
    segments = 36
    segment_angle = 360 / segments
    for i in range(segments):
        current_angle = i * segment_angle
        next_angle = (i + 1) * segment_angle
        if not (gap_angle_start <= current_angle <= gap_angle_end):
            glBegin(GL_TRIANGLES)
            glVertex3f(0, 0, 0)
            rad1 = radians(current_angle)
            glVertex3f(radius * cos(rad1), radius * sin(rad1), 0)
            rad2 = radians(next_angle)
            glVertex3f(radius * cos(rad2), radius * sin(rad2), 0)
            glEnd()
    glPopMatrix()
    battlement_base = [0.55, 0.55, 0.55]
    battlement_color = get_color_scheme(color_scheme, battlement_base)
    battlement_z = z + platform_thickness
    for angle in range(0, 360, 20):
        if not (gap_angle_start <= angle <= gap_angle_end):
            rad = radians(angle)
            bx = x + (radius + 25) * cos(rad)
            by = y + (radius + 25) * sin(rad)
            draw_cube_manual_shading(bx, by, battlement_z + 30, 35, 35, 80, battlement_color)

def draw_tower_with_platform(offset_x, offset_y, offset_z, radius=160, height=800, floors=3, color_scheme='normal'):
    quad = gluNewQuadric()
    glPushMatrix()
    glTranslatef(offset_x, offset_y, offset_z)
    base_stone_color = [0.82, 0.8, 0.72]
    stone_color = get_color_scheme(color_scheme, base_stone_color)
    glColor3f(stone_color[0], stone_color[1], stone_color[2])
    floor_height = height / floors
    for floor in range(floors):
        gluCylinder(quad, radius, radius, floor_height, 32, 32)
        glTranslatef(0, 0, floor_height)
        if floor < floors - 1:
            ring_base = [0.6, 0.6, 0.6]
            ring_color = get_color_scheme(color_scheme, ring_base)
            glColor3f(ring_color[0], ring_color[1], ring_color[2])
            gluCylinder(quad, radius + 5, radius + 5, 10, 32, 32)
            glColor3f(stone_color[0], stone_color[1], stone_color[2])
            glTranslatef(0, 0, 10)
    glPopMatrix()
    platform_z = offset_z + height
    platform_radius = radius + 30
    gap_start = 315
    gap_end = 45
    draw_platform_with_gap(offset_x, offset_y, platform_z, platform_radius, gap_start, gap_end, color_scheme)
    central_base = [0.8, 0.8, 0.75]
    central_color = get_color_scheme(color_scheme, central_base)
    draw_cube_manual_shading(offset_x, offset_y, platform_z + 40, 60, 60, 80, central_color)

def draw_rock_tower():
    x, y, z = central_rock_pos
    rock_color = [0.4, 0.4, 0.35]
    draw_cube_manual_shading(x, y, z + 256, 352, 330, 413, rock_color)
    draw_cube_manual_shading(x - 15, y + 8, z + 650, 308, 286, 375, rock_color)
    draw_cube_manual_shading(x + 12, y - 10, z + 1006, 264, 242, 338, rock_color)
    draw_cube_manual_shading(x - 5, y + 5, z + 1300, 220, 198, 250, rock_color)
    draw_cube_manual_shading(x, y, z + 1488, 165, 154, 125, rock_color)

def draw_rock_tower_platform():
    x, y, z = central_rock_pos
    platform_height = z + 1600
    platform_radius = 120
    platform_thickness = 30
    platform_color = [0.6, 0.6, 0.55]
    glColor3f(platform_color[0], platform_color[1], platform_color[2])
    draw_filled_circle(x, y, platform_height + platform_thickness/2, platform_radius)
    railing_color = [0.5, 0.5, 0.45]
    railing_height = platform_height + platform_thickness + 10
    for angle in range(0, 360, 30):
        rad = radians(angle)
        rail_x = x + (platform_radius - 10) * cos(rad)
        rail_y = y + (platform_radius - 10) * sin(rad)
        draw_cube_manual_shading(rail_x, rail_y, railing_height + 15, 8, 8, 30, railing_color)

def draw_filled_circle(x, y, z, radius, segments=32):
    glPushMatrix()
    glTranslatef(x, y, z)
    glBegin(GL_TRIANGLE_FAN)
    glVertex3f(0.0, 0.0, 0.0)
    for i in range(segments + 1):
        angle = 2 * 3.14159 * i / segments
        px = radius * cos(angle)
        py = radius * sin(angle)
        glVertex3f(px, py, 0.0)
    glEnd()
    glPopMatrix()

def draw_spiral_stairs_around_rock():
    x, y, z = central_rock_pos
    radius = 220
    steps = 80
    total_height = 1600
    height_per_step = total_height / steps
    angle_per_step = 1800 / steps
    stair_color = [0.6, 0.5, 0.4]
    for i in range(steps):
        angle = radians(angle_per_step * i)
        step_x = x + radius * cos(angle)
        step_y = y + radius * sin(angle)
        step_z = z + height_per_step * i
        glPushMatrix()
        glTranslatef(step_x, step_y, step_z)
        glRotatef(angle_per_step * i, 0, 0, 1)
        draw_cube_manual_shading(0, 0, 0, 100, 50, 15, stair_color)
        if i % 10 == 0:
            draw_cube_manual_shading(0, 0, -50, 25, 25, 100, stair_color)
        glPopMatrix()

def draw_rope_connections():
    for config in castle_configs:
        pos = config['position']
        wall_height = config['wall_height']
        castle_center_height = pos[2] + wall_height
        castle_center = [pos[0], pos[1], castle_center_height]
        bar_height = 350
        draw_rope_support_bar(castle_center[0], castle_center[1], castle_center[2], bar_height)
        center_bar_top = [castle_center[0], castle_center[1], castle_center[2] + bar_height - 50]
        rock_platform = [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1600 + 150]
        draw_rope(center_bar_top, rock_platform)
    draw_rope_support_bar(central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1600 + 30, 100)

def draw_wall(x1, y1, x2, y2, offset_z, thickness=400, height=600, color_scheme='normal'):
    midx = (x1 + x2) / 2
    midy = (y1 + y2) / 2
    length = ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    glPushMatrix()
    glTranslatef(midx, midy, offset_z + height/2)
    angle = atan2(y2 - y1, x2 - x1) * 180 / 3.14159
    glRotatef(angle, 0, 0, 1)
    wall_base = [0.85, 0.82, 0.75]
    wall_color = get_color_scheme(color_scheme, wall_base)
    draw_cube_manual_shading(0, 0, 0, length, thickness, height, wall_color)
    glPopMatrix()

def draw_stone_block(x, y, z, width, depth, height, angle, row, col, color_scheme='normal'):
    glPushMatrix()
    glTranslatef(x, y, z)
    glRotatef(angle, 0, 0, 1)
    base_r, base_g, base_b = 0.85, 0.40, 0.35
    variation = 0.12 * ((row + col) % 5 - 2) / 2
    stone_color = [
        min(max(base_r + variation, 0.0), 1.0),
        min(max(base_g + variation, 0.0), 1.0),
        min(max(base_b + variation, 0.0), 1.0)
    ]
    final_color = get_color_scheme(color_scheme, stone_color)
    draw_cube_manual_shading(0, 0, 0, width, depth, height, final_color)
    glPopMatrix()

def draw_stone_blocks(x1, y1, x2, y2, offset_z, thickness, height, color_scheme='normal'):
    length = ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    angle = atan2(y2 - y1, x2 - x1) * 180 / 3.14159
    block_width, block_height, gap = 200, 100, 20
    blocks_x = int(length / (block_width + gap))
    blocks_z = int(height / (block_height + gap))
    midx, midy = (x1 + x2) / 2, (y1 + y2) / 2
    for row in range(blocks_z):
        for col in range(blocks_x):
            offset = (block_width + gap) / 2 if (row % 2 == 1) else 0
            block_x_local = -length/2 + col * (block_width + gap) + block_width/2 + offset
            block_z_local = row * (block_height + gap) + block_height/2
            if abs(block_x_local) > length/2 - block_width/2:
                continue
            cos_a, sin_a = cos(radians(angle)), sin(radians(angle))
            world_x = midx + block_x_local * cos_a
            world_y = midy + block_x_local * sin_a
            world_z = offset_z + block_z_local + 15
            draw_stone_block(world_x, world_y, world_z, block_width, thickness + 5, block_height, angle, row, col, color_scheme)

def draw_chest(x, y, z, size=250):
    chest_color = [0.55, 0.27, 0.07]
    draw_cube_manual_shading(x, y, z + size/4, size, size*0.6, size/2, chest_color)
    lid_color = [0.45, 0.2, 0.05]
    draw_cube_manual_shading(x, y, z + size*0.75, size, size*0.6, size/3, lid_color)
    lock_color = [1.0, 0.84, 0.0]
    draw_cube_manual_shading(x, y + size*0.3, z + size*0.5, size*0.2, size*0.05, size*0.2, lock_color)

def draw_circle_flat(x, y, z, radius, color=[0.55, 0.27, 0.07], segments=64):
    glColor3f(*color)
    glBegin(GL_TRIANGLE_FAN)
    glVertex3f(x, y, z)
    for i in range(segments + 1):
        angle = 2 * 3.14159 * i / segments
        dx = radius * cos(angle)
        dy = radius * sin(angle)
        glVertex3f(x + dx, y + dy, z)
    glEnd()

def draw_wooden_logs_on_largest_castle():
    x, y, z = 1200, 1500, 0
    quad = gluNewQuadric()
    log_radius = 40
    log_length = 320
    num_logs = 5
    spacing = 5
    for i in range(num_logs):
        glPushMatrix()
        glTranslatef(x, y, z + i*(log_radius*2 + spacing))
        glRotatef(90, 0, 1, 0)
        glColor3f(0.55, 0.27, 0.07)
        gluCylinder(quad, log_radius, log_radius, log_length, 16, 16)
        glPopMatrix()

def draw_castle_roof_rectangle(castle):
    """Draw a flat rectangular roof on top of the castle."""
    x, y, z = castle['position']
    half = castle['size'] / 2
    roof_z = z + castle['roof_z']  # use roof_z height from config

    glColor3f(0.7, 0.7, 0.7)  # light grey roof
    glBegin(GL_QUADS)
    glVertex3f(x - half, y - half, roof_z)
    glVertex3f(x + half, y - half, roof_z)
    glVertex3f(x + half, y + half, roof_z)
    glVertex3f(x - half, y + half, roof_z)
    glEnd()


def draw_single_castle(config):
    pos = config['position']
    size = config['size']
    height = config['height']
    tower_radius = config['tower_radius']
    floors = config['floors']
    wall_thickness = config['wall_thickness']
    wall_height = config['wall_height']
    color_scheme = config['color_scheme']
    
    half_size = size / 2
    corners = [
        (pos[0] + half_size, pos[1] + half_size),
        (pos[0] - half_size, pos[1] + half_size),
        (pos[0] - half_size, pos[1] - half_size),
        (pos[0] + half_size, pos[1] - half_size)
    ]
    
    # Draw towers with platforms
    for (x, y) in corners:
        draw_tower_with_platform(x, y, pos[2], tower_radius, height, floors, color_scheme)
    
    # Draw walls
    wall_inset = 50
    for i in range(len(corners)):
        x1, y1 = corners[i]
        x2, y2 = corners[(i + 1) % len(corners)]
        dx, dy = x2 - x1, y2 - y1
        length = (dx**2 + dy**2)**0.5
        dx_norm, dy_norm = dx / length * wall_inset, dy / length * wall_inset
        wall_x1, wall_y1 = x1 + dx_norm, y1 + dy_norm
        wall_x2, wall_y2 = x2 - dx_norm, y2 - dy_norm
        draw_wall(wall_x1, wall_y1, wall_x2, wall_y2, pos[2], wall_thickness, wall_height, color_scheme)
        draw_stone_blocks(wall_x1, wall_y1, wall_x2, wall_y2, pos[2], wall_thickness, wall_height, color_scheme)
    
    # Add railings on top of castle walls
    railing_height = 80
    railing_color = get_color_scheme(color_scheme, [0.6, 0.6, 0.55])
    railing_top_z = pos[2] + wall_height + railing_height/2
    
    for i in range(len(corners)):
        x1, y1 = corners[i]
        x2, y2 = corners[(i + 1) % len(corners)]
        dx, dy = x2 - x1, y2 - y1
        length = (dx**2 + dy**2)**0.5
        dx_norm, dy_norm = dx / length * wall_inset, dy / length * wall_inset
        wall_x1, wall_y1 = x1 + dx_norm, y1 + dy_norm
        wall_x2, wall_y2 = x2 - dx_norm, y2 - dy_norm
        num_railings = int(length / 100)
        for j in range(num_railings + 1):
            t = j / max(num_railings, 1)
            rail_x = wall_x1 + t * (wall_x2 - wall_x1)
            rail_y = wall_y1 + t * (wall_y2 - wall_y1)
            draw_cube_manual_shading(rail_x, rail_y, railing_top_z, 15, 15, railing_height, railing_color)
    
    # Add horizontal railing bars
    railing_bar_color = get_color_scheme(color_scheme, [0.65, 0.65, 0.6])
    for i in range(len(corners)):
        x1, y1 = corners[i]
        x2, y2 = corners[(i + 1) % len(corners)]
        dx, dy = x2 - x1, y2 - y1
        length = (dx**2 + dy**2)**0.5
        dx_norm, dy_norm = dx / length * wall_inset, dy / length * wall_inset
        wall_x1, wall_y1 = x1 + dx_norm, y1 + dy_norm
        wall_x2, wall_y2 = x2 - dx_norm, y2 - dy_norm
        midx = (wall_x1 + wall_x2) / 2
        midy = (wall_y1 + wall_y2) / 2
        glPushMatrix()
        glTranslatef(midx, midy, pos[2] + wall_height + railing_height - 20)
        angle = atan2(wall_y2 - wall_y1, wall_x2 - wall_x1) * 180 / 3.14159
        glRotatef(angle, 0, 0, 1)
        draw_cube_manual_shading(0, 0, 0, length - 2*wall_inset, 10, 8, railing_bar_color)
        glPopMatrix()
    
    # Draw gate
    gate_base = [0.3, 0.3, 0.3]
    gate_color = get_color_scheme(color_scheme, gate_base)
    draw_cube_manual_shading(pos[0], pos[1] - half_size + wall_inset, pos[2] + wall_height/2,
                            300, 80, wall_height, gate_color)
    
    draw_castle_roof_rectangle(config)

# Vegetation and environment (from paste.txt)
def draw_simple_tree(x, y, z, size=100):
    quad = gluNewQuadric()
    glPushMatrix()
    glTranslatef(x, y, z)
    glColor3f(0.4, 0.2, 0.1)
    gluCylinder(quad, size*0.15, size*0.1, size*0.8, 6, 10)
    glTranslatef(0, 0, size*0.6)
    glColor3f(0.1, 0.5, 0.1)
    gluSphere(quad, size*0.6, 8, 8)
    glPopMatrix()

def draw_simple_bush(x, y, z, size=60):
    quad = gluNewQuadric()
    glPushMatrix()
    glTranslatef(x, y, z + size*0.4)
    glColor3f(0.2, 0.4, 0.2)
    gluSphere(quad, size*0.5, 6, 6)
    glPopMatrix()

def draw_multi_colored_grid():
    grid_size = GRID_LENGTH * 20
    quad_size = 800
    num_quads = (grid_size * 2) // quad_size
    green_colors = [
        [0.15, 0.4, 0.15], [0.2, 0.5, 0.2], [0.25, 0.6, 0.25], [0.3, 0.7, 0.3],
        [0.35, 0.75, 0.35], [0.4, 0.8, 0.4], [0.2, 0.45, 0.2], [0.18, 0.55, 0.18]
    ]
    for i in range(num_quads):
        for j in range(num_quads):
            x1 = -grid_size + i * quad_size
            y1 = -grid_size + j * quad_size
            x2 = x1 + quad_size
            y2 = y1 + quad_size
            color_index = (i + j) % len(green_colors)
            color = green_colors[color_index]
            glColor3f(color[0], color[1], color[2])
            glBegin(GL_QUADS)
            glVertex3f(x1, y1, 0)
            glVertex3f(x2, y1, 0)
            glVertex3f(x2, y2, 0)
            glVertex3f(x1, y2, 0)
            glEnd()
    glColor3f(0.1, 0.3, 0.1)
    glLineWidth(1.0)
    glBegin(GL_LINES)
    for i in range(num_quads + 1):
        line_x = -grid_size + i * quad_size
        glVertex3f(line_x, -grid_size, 1)
        glVertex3f(line_x, grid_size, 1)
    for j in range(num_quads + 1):
        line_y = -grid_size + j * quad_size
        glVertex3f(-grid_size, line_y, 1)
        glVertex3f(grid_size, line_y, 1)
    glEnd()

def draw_minimal_vegetation():
    tree_positions = [
        (-5000, -3000), (-4000, 2000), (-2000, -4000), (3000, -2000), (4000, 3000),
        (-6000, 1000), (2000, -5000), (5000, -1000), (-1000, -6000), (6000, 2000),
        (-3000, 4000), (1000, 5000), (-5000, 0), (0, -3000), (4000, 0)
    ]
    bush_positions = [
        (-4500, -2500), (-3500, 1500), (-1500, -3500), (2500, -1500), (3500, 2500),
        (-5500, 500), (1500, -4500), (4500, -500), (-500, -5500), (5500, 1500),
        (-2500, 3500), (500, 4500), (-4500, -500), (-500, -2500), (3500, -500),
        (-1500, 4500), (4500, 500), (-3500, -1500), (2500, 3500), (-500, 5500),
        (-6000, -1000), (1000, -6000), (6000, 1000), (-1000, 6000), (0, -4000)
    ]
    def is_safe_position(x, y):
        castle_centers = [[-800, -1600], [900, 1000], [-3300, 400], [-1000, 1500]]
        for cx, cy in castle_centers:
            if sqrt((x - cx)**2 + (y - cy)**2) < 900:
                return False
        return True
    for x, y in tree_positions:
        if is_safe_position(x, y):
            draw_simple_tree(x, y, 30, 240)
    for x, y in bush_positions:
        if is_safe_position(x, y):
            draw_simple_bush(x, y, 0, 190)

def draw_mountain_range():
    mountain_positions = [
        # NORTH CLUSTER
        (-2746, 6714, 0, 825, 1079, 740), (-1150, 8828, 0, 942, 1077, 652),
        (-2708, 7358, 0, 1358, 744, 816), (-1368, 8630, 0, 895, 811, 719),
        (-2883, 7216, 0, 827, 987, 701), (-1100, 9100, 0, 1200, 900, 800),
        (-2600, 6900, 0, 1000, 850, 750),
        # SOUTH CLUSTER
        (-167, -6735, 0, 1358, 914, 712), (-2441, -8797, 0, 1084, 703, 681),
        (-186, -6968, 0, 1148, 842, 679), (-2680, -8619, 0, 1144, 752, 647),
        (-511, -7301, 0, 1167, 876, 735), (-2300, -8800, 0, 1100, 800, 700),
        (-800, -7000, 0, 900, 750, 650),
        # EAST CLUSTER
        (6644, -1653, 0, 1270, 974, 663), (8987, -320, 0, 1365, 850, 785),
        (7191, -2204, 0, 871, 723, 716), (9391, -104, 0, 881, 819, 651),
        (6989, -2116, 0, 1264, 1025, 786), (9100, 200, 0, 1000, 900, 750),
        (6800, -2000, 0, 1200, 850, 700),
        # WEST CLUSTER
        (-7234, 479, 0, 1163, 807, 736), (-8682, -1201, 0, 873, 1011, 687),
        (-6854, 846, 0, 1050, 783, 836), (-9012, -1624, 0, 1370, 812, 766),
        (-6614, 894, 0, 857, 817, 616), (-8900, -1400, 0, 1100, 950, 800),
        (-7200, 700, 0, 950, 800, 650)
    ]
    for x, y, z, width, height, depth in mountain_positions:
        draw_rocky_mountain(x, y, z, width, height, depth)

def draw_rocky_mountain(x, y, z, width=800, height=600, depth=600):
    quad = gluNewQuadric()
    base_color = [0.5, 0.4, 0.35]
    glPushMatrix()
    glTranslatef(x, y, z)
    glColor3f(base_color[0], base_color[1], base_color[2])
    glPushMatrix()
    glScalef(width/200, depth/200, height/200)
    gluSphere(quad, 100, 12, 8)
    glPopMatrix()
    glPopMatrix()

def draw_hp_bar_for_castle(cfg_id):
    if cfg_id not in wall_hp:
        return
    cfg = castle_configs[cfg_id]
    cx, cy, _ = cfg['position']
    posx = cx
    posy = cy
    posz = cfg['height'] + cfg['wall_height'] + 180.0
    hp = wall_hp[cfg_id]
    hpmax = wall_max[cfg_id]
    pct = hp / float(hpmax) if hpmax > 0 else 0.0
    
    glColor3f(0.15, 0.15, 0.15)
    glBegin(GL_QUADS)
    glVertex3f(posx-150, posy, posz)
    glVertex3f(posx+150, posy, posz)
    glVertex3f(posx+150, posy, posz+16)
    glVertex3f(posx-150, posy, posz+16)
    glEnd()
    glColor3f(1.0-pct, pct, 0.1)
    glBegin(GL_QUADS)
    glVertex3f(posx-148, posy+0.1, posz+2)
    glVertex3f(posx-148 + 296*pct, posy+0.1, posz+2)
    glVertex3f(posx-148 + 296*pct, posy+0.1, posz+14)
    glVertex3f(posx-148, posy+0.1, posz+14)
    glEnd()
    

def draw_all_structures():
    TELEPORT_RADIUS = 120
    
    # Disable lighting for manually shaded structures
    
    
    # Individual castles
    for config in castle_configs:
        draw_single_castle(config)
        
        # Draw chest if this castle has one
        if config.get('chest'):
            chest = config['chest']
            draw_chest(chest['position'][0], chest['position'][1], chest['position'][2])
        
        # Draw teleport circles
        cx, cy, cz = config['position']
        roof_z = cz + config['roof_z']
        draw_circle_flat(cx, cy, roof_z + 15, TELEPORT_RADIUS, color=[0.55, 0.27, 0.07])
        draw_circle_flat(cx, cy, cz + 2, TELEPORT_RADIUS, color=[1.0, 1.0, 1.0])
    
    # Wooden logs on largest castle
    draw_wooden_logs_on_largest_castle()
    
    # Central rock tower with platform
    draw_rock_tower()
    draw_rock_tower_platform()
    draw_spiral_stairs_around_rock()
    
    # Rope connections
    draw_rope_connections()
    
    # Perimeter wall (excludes largest castle)
    draw_perimeter_wall()
    
    # Re-enable lighting for other objects
    
    
    # Draw player if not in FPP
    if not fpp_mode:
         # Temporarily disable for player
        draw_human(player_pos[0], player_pos[1], player_pos[2], scale=60)
        

def draw_text(x, y, text, font=None):
    if font is None:
        try:
            font = GLUT_BITMAP_HELVETICA_18
        except NameError:
            font = GLUT_BITMAP_9_BY_15
    
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, 1000, 0, 800)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

# Collision and game logic
def is_player_on_chest(player_pos, chest):
    px, py, pz = player_pos
    cx, cy, cz = 1200, 500, 0
    distance_threshold = chest['size'] / 2 + 20
    dx = abs(px - cx)
    dy = abs(py - cy)
    dz = abs(pz - cz)
    return dx <= distance_threshold and dy <= distance_threshold and dz <= distance_threshold

def is_player_on_wooden_logs(player_pos):
    px, py, pz = player_pos
    log_x, log_y, log_z = 1200, 1500, 0
    distance_threshold = 200
    dx = px - log_x
    dy = py - log_y
    dz = pz - log_z
    distance = (dx**2 + dy**2 + dz**2)**0.5
    return distance <= distance_threshold

def clamp_player_position():
    global player_pos, teleport_skip_clamp
    
    if teleport_skip_clamp:
        teleport_skip_clamp = False
        return
    
    x, y, z = player_pos
    
    def get_castle_boundaries(castle_config):
        pos = castle_config['position']
        size = castle_config['size']
        wall_height = castle_config['wall_height']
        wall_inset = 50
        half_size = size / 2
        min_x = pos[0] - half_size + wall_inset
        max_x = pos[0] + half_size - wall_inset
        min_y = pos[1] - half_size + wall_inset
        max_y = pos[1] + half_size - wall_inset
        z_min = 0
        z_max = pos[2] + wall_height + 200
        return min_x, max_x, min_y, max_y, z_min, z_max
    
    # Check each castle individually
    for i, castle in enumerate(castle_configs):
        min_x, max_x, min_y, max_y, z_min, z_max = get_castle_boundaries(castle)
        BUFFER_ZONE = 100
        if (min_x - BUFFER_ZONE <= x <= max_x + BUFFER_ZONE and 
            min_y - BUFFER_ZONE <= y <= max_y + BUFFER_ZONE and 
            z_min <= z <= z_max):
            player_pos[0] = max(min_x, min(x, max_x))
            player_pos[1] = max(min_y, min(y, max_y))
            player_pos[2] = max(z_min, min(z, z_max))
            return
    
    # Central rock platform
    rock_x, rock_y, rock_z = central_rock_pos
    rock_radius = 120
    rock_height_min = rock_z + 1600
    rock_height_max = rock_z + 1800
    if rock_height_min <= z <= rock_height_max:
        dist_from_center = sqrt((x - rock_x)**2 + (y - rock_y)**2)
        if dist_from_center <= rock_radius:
            if dist_from_center > rock_radius - 10:
                direction_x = (x - rock_x) / max(dist_from_center, 0.1)
                direction_y = (y - rock_y) / max(dist_from_center, 0.1)
                player_pos[0] = rock_x + direction_x * (rock_radius - 10)
                player_pos[1] = rock_y + direction_y * (rock_radius - 10)
            return
    
    # Spiral stairs around rock tower
    if rock_z <= z <= rock_z + 1600:
        stair_radius = 220
        dist_from_rock = sqrt((x - rock_x)**2 + (y - rock_y)**2)
        if 180 <= dist_from_rock <= 260:
            return
    
    # Perimeter wall area
    buildings = [castle_configs[0], castle_configs[2], {'position': central_rock_pos, 'size': 800}]
    min_x = min([pos['position'][0] - pos['size']/2 for pos in buildings]) - 500
    max_x = max([pos['position'][0] + pos['size']/2 for pos in buildings]) + 500
    min_y = min([pos['position'][1] - pos['size']/2 for pos in buildings]) - 500
    max_y = max([pos['position'][1] + pos['size']/2 for pos in buildings]) + 500
    if 0 <= z <= 450:
        if min_x <= x <= max_x and min_y <= y <= max_y:
            if x < min_x: player_pos[0] = min_x
            elif x > max_x: player_pos[0] = max_x
            if y < min_y: player_pos[1] = min_y
            elif y > max_y: player_pos[1] = max_y
            return
    
    # Find nearest castle and move to edge
    min_dist = float('inf')
    nearest_castle = None
    for castle in castle_configs:
        cx, cy = castle['position'][0], castle['position'][1]
        dist = sqrt((x - cx)**2 + (y - cy)**2)
        if dist < min_dist:
            min_dist = dist
            nearest_castle = castle
    
    if nearest_castle:
        min_x, max_x, min_y, max_y, z_min, z_max = get_castle_boundaries(nearest_castle)
        clamp_x = max(min_x, min(x, max_x))
        clamp_y = max(min_y, min(y, max_y))
        player_pos[0] = clamp_x
        player_pos[1] = clamp_y
        player_pos[2] = nearest_castle['position'][2] + nearest_castle['wall_height']


def heal_castle():
    global player_coins, castle_health, max_castle_health
    COST = 50
    HEAL_AMOUNT = 20
    if player_coins >= COST and castle_health < max_castle_health:
        player_coins -= COST
        castle_health = min(max_castle_health, castle_health + HEAL_AMOUNT)
        print(f"Castle healed by {HEAL_AMOUNT}! Health = {castle_health}, Coins left = {player_coins}")
    else:
        print("Not enough coins or castle already at max health.")


def restart_game():
    global pause, show_trails, wireframe, enemies, projectiles, effects
    global wall_hp, wall_max, all_walls
    global player_coins, castle_health, max_castle_health, player_arrows
    global last_chest_time, teleport_skip_clamp
    global camera_radius, camera_height, cam_angle_h, cam_angle_v, fpp_mode
    global spawn_flags, spawn_timers
    global player_pos, player_speed, player_angle, player_turn_speed

    # Reset game state
    pause = False
    show_trails = False
    wireframe = False
    enemies = []
    projectiles = []
    effects = []
    wall_hp = {}
    wall_max = {}
    all_walls = []

    # Reset player stats
    player_coins = 0
    castle_health = 100
    max_castle_health = 200
    player_arrows = 0
    last_chest_time = 0
    teleport_skip_clamp = False

    # Reset camera
    cam_angle_h = 45
    cam_angle_v = 30
    camera_radius = 8000
    camera_height = 2500
    fpp_mode = False
    update_camera_pos()  # make sure camera_pos matches

    # Reset enemy spawning
    spawn_flags = {'barbarian': True, 'archer': True, 'giant': True, 'cannon': True}
    spawn_timers = {'barbarian': 0.0, 'archer': 0.0, 'giant': 0.0, 'cannon': 0.0}

    # Reset player position
    player_pos = [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]
    player_speed = 50
    player_angle = 0
    player_turn_speed = 5

    print("Game restarted!")

def setup_camera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    fov = 70 if fpp_mode else fovY
    gluPerspective(fov, 1.25, 1.0, 30000)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    
    if fpp_mode:
        eye_x, eye_y, eye_z = player_pos
        eye_z += 120
        rad = radians(player_angle + 90)
        look_x = eye_x + cos(rad) * 5
        look_y = eye_y + sin(rad) * 5
        look_z = eye_z
        gluLookAt(eye_x, eye_y, eye_z, look_x, look_y, look_z, 0, 0, 1)
    else:
        eye_x, eye_y, eye_z = camera_pos
        center_x, center_y, center_z = -1000, 0, 600
        gluLookAt(eye_x, eye_y, eye_z, center_x, center_y, center_z, 0, 0, 1)

# Main update loop
prev_time = None
def update():
    global prev_time
    t = glutGet(GLUT_ELAPSED_TIME) / 1000.0
    if prev_time is None:
        prev_time = t
    dt = min(0.04, max(0.001, t - prev_time))
    prev_time = t
    if not pause:
        update_spawning(dt)
        for e in list(enemies):
            e.update(dt)
            if e.hp <= 0:
                effects.append(ParticleBurst([e.pos[0], e.pos[1], 100], size=50, count=30))
                enemies.remove(e)
        alive = []

        # Update player arrows
        for arrow in player_arrows_fired[:]:
            arrow.update(dt)
            if not arrow.active:
                player_arrows_fired.remove(arrow)









































        for p in projectiles:
            p.update(dt)
            if p.life <= 0 or p.pos[2] < -50:
                continue
            hit = False
            for wall in all_walls:
                if wall.intersects(p.pos) and p.pos[2] < wall.height:
                    effects.append(ParticleBurst(p.pos, size=80 if p.kind == 'ball' else 24, count=56 if p.kind == 'ball' else 18))
                    owner = wall.owner
                    if owner in wall_hp:
                        wall_hp[owner] = max(0, wall_hp[owner] - p.damage)
                    hit = True
                    break
            if not hit:
                alive.append(p)
        projectiles[:] = alive
        for ef in list(effects):
            ef.update(dt)
            if ef.life <= 0:
                effects.remove(ef)
    glutPostRedisplay()

def show_screen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, 1000, 800)
    setup_camera()
    
    
    # Draw grid with manual shading
    
    draw_multi_colored_grid()
    
    
    # Draw all structures (manual shading handled inside function)
    draw_all_structures()
    
    # Draw environment with manual shading
    
    draw_mountain_range()
    draw_minimal_vegetation()
    
    
    # Draw enemies and effects (with lighting)
    for e in list(enemies):
        e.draw()
    for p in list(projectiles):
        p.draw()
    for ef in effects:
        ef.draw()
    for i in range(len(castle_configs)):
        draw_hp_bar_for_castle(i)
    # Draw player arrows
    for arrow in player_arrows_fired:
        arrow.draw()    
    # Display UI
    
    draw_light_bow()
    draw_text(10, 770, f"Coins: {player_coins}")
    draw_text(10, 740, f"Arrows: {player_arrows}")
    draw_text(10, 710, f"Castle Health: {castle_health}")
    draw_text(10, 680, f"Enemies: {len(enemies)}")
    draw_text(10, 650, f"Wall HP: {wall_hp.get(0, 0)}")
    draw_text(10, 620, "Controls: Arrows=Camera, Z/X=Zoom, WASD=Move, F=Collect, E=Teleport, H=Heal")
    draw_text(10, 590, "1-3=Castle Teleport, 4=Return to Spawn, Space=Pause, T=Trails, RMB=FPP")
    
    
    glutSwapBuffers()

def update_camera_pos():
    global camera_pos, camera_radius, cam_angle_h, camera_height
    camera_pos[0] = camera_radius * cos(cam_angle_h)
    camera_pos[1] = camera_radius * sin(cam_angle_h)
    camera_pos[2] = camera_height

def handle_special_keys(key, x, y):
    global cam_angle_h, camera_radius, camera_height, camera_pos
    
    angle_step = radians(2)
    height_step = 100
    
    if key == GLUT_KEY_LEFT:
        cam_angle_h -= angle_step
    elif key == GLUT_KEY_RIGHT:
        cam_angle_h += angle_step
    elif key == GLUT_KEY_UP:
        camera_height += height_step
    elif key == GLUT_KEY_DOWN:
        camera_height = max(0, camera_height - height_step)

    update_camera_pos()
    
    
    glutPostRedisplay()

update_camera_pos()


def handle_mouse_button(button, state, x, y):
    global fpp_mode,surrender
    if surrender == True:
        return
    if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
        fpp_mode = not fpp_mode
        print("FPP mode activated" if fpp_mode else "FPP mode deactivated")
    # Add left click to shoot arrows
    elif button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        shoot_arrow()


        
def handle_keyboard(key, x, y):
    global cam_dist, player_pos, player_angle, player_speed, player_turn_speed, player_coins, last_chest_time, player_arrows, camera_radius, min_radius, max_radius, pause, show_trails, wireframe, teleport_skip_clamp, surrender
    
    k = key.decode("utf-8").lower()
    zoom_step = 200
    
    # Camera zoom
    if k == 'z':
        camera_radius = max(min_radius, camera_radius - zoom_step)
    elif k == 'x':
        camera_radius = min(max_radius, camera_radius + zoom_step)
    
    update_camera_pos()

    if k == 'r':
        surrender = False
        restart_game()

    if surrender == True:
        return
    
    # Player rotation
    if k == 'a':
        player_angle += player_turn_speed
    elif k == 'd':
        player_angle -= player_turn_speed



    elif k == '0':
        surrender = True
        


    elif k == 'w':
        if player_pos != [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]:
            rad = radians(player_angle + 90)
            player_pos[0] += player_speed * cos(rad)
            player_pos[1] += player_speed * sin(rad)
            clamp_player_position()
    elif k == 's':
        if player_pos != [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]:
            rad = radians(player_angle + 90)
            player_pos[0] -= player_speed * cos(rad)
            player_pos[1] -= player_speed * sin(rad)
            clamp_player_position()
    
    # Collection system
    elif k == 'f':
        current_time = time.time()
        if current_time - last_chest_time >= CHEST_COOLDOWN:
            for config in castle_configs:
                chest = config.get('chest')
                if chest and is_player_on_chest(player_pos, chest):
                    player_coins += 100
                    last_chest_time = current_time
                    print(f"Collected 100 coins! Total coins: {player_coins}")
                    break
        else:
            print("Chest is recharging... wait a few seconds.")
        
        if is_player_on_wooden_logs(player_pos):
            player_arrows += 100
            print(f"Collected arrows! Total: {player_arrows}")
    
    # Teleport to castle roofs
    elif k in ['1', '2', '3']:
        if player_pos == [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]:
            teleport_skip_clamp = True
            index = int(k) - 1
            castle = castle_configs[index]
            player_pos[0] = castle['position'][0]
            player_pos[1] = castle['position'][1]
            player_pos[2] = castle['position'][2] + castle['roof_z'] + 75
            half = castle['size'] / 2
            player_pos[0] = max(castle['position'][0]-half, min(player_pos[0], castle['position'][0]+half))
            player_pos[1] = max(castle['position'][1]-half, min(player_pos[1], castle['position'][1]+half))
    
    elif key == b'4':  # teleport back to spawn
        CENTER_RADIUS = 150
        for castle in castle_configs:
            cx, cy, cz = castle['position']
            dx = player_pos[0] - cx
            dy = player_pos[1] - cy
            distance = (dx**2 + dy**2)**0.5
            if distance <= CENTER_RADIUS:
                teleport_skip_clamp = True
                player_pos = [central_rock_pos[0], central_rock_pos[1], central_rock_pos[2] + 1630]
                print(f"Player teleported to spawn from center of castle at {castle['position']}")
                break
    
    elif k == 'e':  # teleport up or down
        TELEPORT_RADIUS = 120
        WOOD_THICKNESS = 20
        for castle in castle_configs:
            cx, cy, cz = castle['position']
            roof_z = cz + castle['roof_z']
            dx = player_pos[0] - cx
            dy = player_pos[1] - cy
            distance = (dx**2 + dy**2)**0.5
            if distance <= TELEPORT_RADIUS and player_pos[2] >= roof_z:
                player_pos[0] = cx
                player_pos[1] = cy
                player_pos[2] = cz + 50
                print(f"Player teleported down from roof of castle at {castle['position']}")
                break
            elif distance <= TELEPORT_RADIUS and abs(player_pos[2] - (cz + 50)) < 100:
                player_pos[0] = cx
                player_pos[1] = cy
                player_pos[2] = roof_z + WOOD_THICKNESS / 2
                print(f"Player teleported up to roof of castle at {castle['position']}")
                break
    
    elif k == 'h':
        heal_castle()
    
    elif k == 't':
        teleport_skip_clamp = True
        player_pos[0] = central_rock_pos[0]
        player_pos[1] = central_rock_pos[1] 
        player_pos[2] = central_rock_pos[2] + 1630
        print(f"Teleported to Tower Top at ({player_pos[0]}, {player_pos[1]}, {player_pos[2]})")
    
    elif k == 'g':
        teleport_skip_clamp = True
        ground_level = 50
        player_pos[2] = ground_level
        print(f"Dropped to ground at ({player_pos[0]}, {player_pos[1]}, {player_pos[2]})")
        clamp_player_position()
    
    # Game controls
    elif k == ' ':
        pause = not pause
    elif k == 'v':
        show_trails = not show_trails
    elif k == 'b':
        wireframe = not wireframe
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE if wireframe else GL_FILL)
    elif k in ['5', '6', '7', '8']:  # Manual enemy spawning
        spawn_enemy(['barbarian', 'archer', 'giant', 'cannon'][int(k)-5])
    elif k == 'q' or key == b'\x1b':
        sys.exit(0)
    
    glutPostRedisplay()

def main():
    try:
        glutInit(sys.argv)
        print("GLUT initialized")
    except Exception as e:
        print(f"GLUT initialization failed: {e}")
        sys.exit(1)
    
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(1000, 800)
    glutInitWindowPosition(0, 0)
    glutCreateWindow(b"Castle Defense - Complete Game")
    
    glEnable(GL_DEPTH_TEST)

    
    # Initialize game state
    for i in range(len(castle_configs)):
        wall_hp[i] = 1000
        wall_max[i] = 1000
    wall_hp['perimeter'] = 5000
    wall_max['perimeter'] = 5000
    
    init_walls()
    
    glutDisplayFunc(show_screen)
    glutIdleFunc(update)
    glutSpecialFunc(handle_special_keys)
    glutKeyboardFunc(handle_keyboard)
    glutMouseFunc(handle_mouse_button)
    
    glutMainLoop()

if __name__ == "__main__":
    main()
